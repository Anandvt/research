/* opcodes.h - generated by gencode */

/** OPCODE CONSTANTS **/
#define NOOP    0000  /* does nothing */
#define PUSH    0x01  /* push a register onto data stack */
#define POP     0x02  /* pop data stack top into a register */
#define SET     0x03  /* set register value */
#define SWAP    0x04  /* swap two register values */
#define ADD     0x05  /* add the second operand to the first */
#define SUB     0x06  /* subtract the second operand from the first */
#define MULT    0x07  /* multiply the first operand by the second */
#define DIV     0x08  /* divide the first operand by the second */
#define MOD     0x09  /* modulo the first operand by the second */
#define CALL    0x0a  /* call a user-defined function */
#define RET     0x0b  /* return to caller */
#define CMP     0x0c  /* compare two integers */
#define STRCMP  0x0d  /* compare two strings */
#define JMP     0x0e  /* unconditional jump */
#define JZ      0x0f  /* jump if accumulator is 0 */
#define JNZ     0x10  /* jump if accumulator is not 0 */
#define JE      0x11  /* jump if accumulator is equal to first operand */
#define JNE     0x12  /* jump if accumulator is not equal to first operand */
#define JGT     0x13  /* jump if accumulator is greater than first operand */
#define JGTE    0x14  /* jump if accumulator is greater than or equal to first operand */
#define JLT     0x15  /* jump if accumulator is less than first operand */
#define JLTE    0x16  /* jump if accumulator is less than or equal to first operand */
#define STRING  0x17  /* format a (heap-allocated) string */
#define PRINT   0x18  /* print a message to standard output */
#define DUMP    0x19  /* dump virtual machine state for debugging */
#define HALT    0x1a  /* halt the virtual machine */


#ifdef OPCODES_EXTENDED
/** OPCODE MNEMONIC NAMES **/
static const char * OPCODES[] = {
	"noop",   /* NOOP     0  0000 */
	"push",   /* PUSH     1  0x01 */
	"pop",    /* POP      2  0x02 */
	"set",    /* SET      3  0x03 */
	"swap",   /* SWAP     4  0x04 */
	"add",    /* ADD      5  0x05 */
	"sub",    /* SUB      6  0x06 */
	"mult",   /* MULT     7  0x07 */
	"div",    /* DIV      8  0x08 */
	"mod",    /* MOD      9  0x09 */
	"call",   /* CALL    10  0x0a */
	"ret",    /* RET     11  0x0b */
	"cmp",    /* CMP     12  0x0c */
	"strcmp", /* STRCMP  13  0x0d */
	"jmp",    /* JMP     14  0x0e */
	"jz",     /* JZ      15  0x0f */
	"jnz",    /* JNZ     16  0x10 */
	"je",     /* JE      17  0x11 */
	"jne",    /* JNE     18  0x12 */
	"jgt",    /* JGT     19  0x13 */
	"jgte",   /* JGTE    20  0x14 */
	"jlt",    /* JLT     21  0x15 */
	"jlte",   /* JLTE    22  0x16 */
	"string", /* STRING  23  0x17 */
	"print",  /* PRINT   24  0x18 */
	"dump",   /* DUMP    25  0x19 */
	"halt",   /* HALT    26  0x1a */
	NULL,
};


/** ASM TOKENS **/
#define T_OPCODE_NOOP    0x40  /* does nothing */
#define T_OPCODE_PUSH    0x41  /* push a register onto data stack */
#define T_OPCODE_POP     0x42  /* pop data stack top into a register */
#define T_OPCODE_SET     0x43  /* set register value */
#define T_OPCODE_SWAP    0x44  /* swap two register values */
#define T_OPCODE_ADD     0x45  /* add the second operand to the first */
#define T_OPCODE_SUB     0x46  /* subtract the second operand from the first */
#define T_OPCODE_MULT    0x47  /* multiply the first operand by the second */
#define T_OPCODE_DIV     0x48  /* divide the first operand by the second */
#define T_OPCODE_MOD     0x49  /* modulo the first operand by the second */
#define T_OPCODE_CALL    0x4a  /* call a user-defined function */
#define T_OPCODE_RET     0x4b  /* return to caller */
#define T_OPCODE_RETV    0x4c  /* return to caller (with value) */
#define T_OPCODE_CMP     0x4d  /* compare two integers */
#define T_OPCODE_STRCMP  0x4e  /* compare two strings */
#define T_OPCODE_JMP     0x4f  /* unconditional jump */
#define T_OPCODE_JZ      0x50  /* jump if accumulator is 0 */
#define T_OPCODE_JNZ     0x51  /* jump if accumulator is not 0 */
#define T_OPCODE_JE      0x52  /* jump if accumulator is equal to first operand */
#define T_OPCODE_JNE     0x53  /* jump if accumulator is not equal to first operand */
#define T_OPCODE_JGT     0x54  /* jump if accumulator is greater than first operand */
#define T_OPCODE_JGTE    0x55  /* jump if accumulator is greater than or equal to first operand */
#define T_OPCODE_JLT     0x56  /* jump if accumulator is less than first operand */
#define T_OPCODE_JLTE    0x57  /* jump if accumulator is less than or equal to first operand */
#define T_OPCODE_STRING  0x58  /* format a (heap-allocated) string */
#define T_OPCODE_PRINT   0x59  /* print a message to standard output */
#define T_OPCODE_DUMP    0x5a  /* dump virtual machine state for debugging */
#define T_OPCODE_HALT    0x5b  /* halt the virtual machine */


static const char * ASM[] = {
	"noop",   /* T_OPCODE_NOOP     0  0000 */
	"push",   /* T_OPCODE_PUSH     1  0x01 */
	"pop",    /* T_OPCODE_POP      2  0x02 */
	"set",    /* T_OPCODE_SET      3  0x03 */
	"swap",   /* T_OPCODE_SWAP     4  0x04 */
	"add",    /* T_OPCODE_ADD      5  0x05 */
	"sub",    /* T_OPCODE_SUB      6  0x06 */
	"mult",   /* T_OPCODE_MULT     7  0x07 */
	"div",    /* T_OPCODE_DIV      8  0x08 */
	"mod",    /* T_OPCODE_MOD      9  0x09 */
	"call",   /* T_OPCODE_CALL    10  0x0a */
	"ret",    /* T_OPCODE_RET     11  0x0b */
	"retv",   /* T_OPCODE_RETV    12  0x0c */
	"cmp",    /* T_OPCODE_CMP     13  0x0d */
	"strcmp", /* T_OPCODE_STRCMP  14  0x0e */
	"jmp",    /* T_OPCODE_JMP     15  0x0f */
	"jz",     /* T_OPCODE_JZ      16  0x10 */
	"jnz",    /* T_OPCODE_JNZ     17  0x11 */
	"je",     /* T_OPCODE_JE      18  0x12 */
	"jne",    /* T_OPCODE_JNE     19  0x13 */
	"jgt",    /* T_OPCODE_JGT     20  0x14 */
	"jgte",   /* T_OPCODE_JGTE    21  0x15 */
	"jlt",    /* T_OPCODE_JLT     22  0x16 */
	"jlte",   /* T_OPCODE_JLTE    23  0x17 */
	"string", /* T_OPCODE_STRING  24  0x18 */
	"print",  /* T_OPCODE_PRINT   25  0x19 */
	"dump",   /* T_OPCODE_DUMP    26  0x1a */
	"halt",   /* T_OPCODE_HALT    27  0x1b */
	NULL,
};

#define ARG_NONE      0x00
#define ARG_REGISTER  0x01
#define ARG_NUMBER    0x02
#define ARG_STRING    0x04
#define ARG_LABEL     0x08
#define ARG_FUNCTION  0x10

static struct {
	byte_t      token;
	const char *usage;
	byte_t      opcode;
	byte_t      args[2];
} ASM_SYNTAX[] = {
	{ T_OPCODE_NOOP,   "noop",                               NOOP,   { ARG_NONE,                           ARG_NONE,                           } },
	{ T_OPCODE_PUSH,   "push %a",                            PUSH,   { ARG_REGISTER,                       ARG_NONE,                           } },
	{ T_OPCODE_POP,    "pop %a",                             POP,    { ARG_REGISTER,                       ARG_NONE,                           } },
	{ T_OPCODE_SET,    "set %a (%b|<string>|<number>)",      SET,    { ARG_REGISTER,                       ARG_REGISTER|ARG_STRING|ARG_NUMBER, } },
	{ T_OPCODE_SWAP,   "swap %a %b",                         SWAP,   { ARG_REGISTER,                       ARG_REGISTER,                       } },
	{ T_OPCODE_ADD,    "add %a (%b|<number>)",               ADD,    { ARG_REGISTER,                       ARG_REGISTER|ARG_NUMBER,            } },
	{ T_OPCODE_SUB,    "sub %a (%b|<number>)",               SUB,    { ARG_REGISTER,                       ARG_REGISTER|ARG_NUMBER,            } },
	{ T_OPCODE_MULT,   "mult %a (%b|<number>)",              MULT,   { ARG_REGISTER,                       ARG_REGISTER|ARG_NUMBER,            } },
	{ T_OPCODE_DIV,    "div %a (%b|<number>)",               DIV,    { ARG_REGISTER,                       ARG_REGISTER|ARG_NUMBER,            } },
	{ T_OPCODE_MOD,    "mod %a (%b|<number>)",               MOD,    { ARG_REGISTER,                       ARG_REGISTER|ARG_NUMBER,            } },
	{ T_OPCODE_CALL,   "call <function>",                    CALL,   { ARG_FUNCTION,                       ARG_NONE,                           } },
	{ T_OPCODE_RET,    "ret",                                RET,    { ARG_NONE,                           ARG_NONE,                           } },
	{ T_OPCODE_RETV,   "retv (%a|<string>|<number>)",        RET,    { ARG_REGISTER|ARG_STRING|ARG_NUMBER, ARG_NONE,                           } },
	{ T_OPCODE_CMP,    "cmp (%a|<number>) (%b|<number>)",    CMP,    { ARG_REGISTER|ARG_NUMBER,            ARG_REGISTER|ARG_NUMBER,            } },
	{ T_OPCODE_STRCMP, "strcmp (%a|<string>) (%b|<string>)", STRCMP, { ARG_REGISTER|ARG_STRING,            ARG_REGISTER|ARG_STRING,            } },
	{ T_OPCODE_JMP,    "jmp <label>",                        JMP,    { ARG_LABEL,                          ARG_NONE,                           } },
	{ T_OPCODE_JZ,     "jz <label>",                         JZ,     { ARG_LABEL,                          ARG_NONE,                           } },
	{ T_OPCODE_JNZ,    "jnz <label>",                        JNZ,    { ARG_LABEL,                          ARG_NONE,                           } },
	{ T_OPCODE_JE,     "je (%a|<number>) <label>",           JE,     { ARG_REGISTER|ARG_NUMBER,            ARG_LABEL,                          } },
	{ T_OPCODE_JNE,    "jne (%a|<number>) <label>",          JNE,    { ARG_REGISTER|ARG_NUMBER,            ARG_LABEL,                          } },
	{ T_OPCODE_JGT,    "jgt (%a|<number>) <label>",          JGT,    { ARG_REGISTER|ARG_NUMBER,            ARG_LABEL,                          } },
	{ T_OPCODE_JGTE,   "jgte (%a|<number>) <label>",         JGTE,   { ARG_REGISTER|ARG_NUMBER,            ARG_LABEL,                          } },
	{ T_OPCODE_JLT,    "jlt (%a|<number>) <label>",          JLT,    { ARG_REGISTER|ARG_NUMBER,            ARG_LABEL,                          } },
	{ T_OPCODE_JLTE,   "jlte (%a|<number>) <label>",         JLTE,   { ARG_REGISTER|ARG_NUMBER,            ARG_LABEL,                          } },
	{ T_OPCODE_STRING, "string (<string>|%a) %b",            STRING, { ARG_STRING|ARG_REGISTER,            ARG_REGISTER,                       } },
	{ T_OPCODE_PRINT,  "print <string>",                     PRINT,  { ARG_STRING,                         ARG_NONE,                           } },
	{ T_OPCODE_DUMP,   "dump",                               DUMP,   { ARG_NONE,                           ARG_NONE,                           } },
	{ T_OPCODE_HALT,   "halt",                               HALT,   { ARG_NONE,                           ARG_NONE,                           } },
	{ 0, 0, 0, { 0, 0 } },
};

#endif
